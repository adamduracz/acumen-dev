package acumen.interpreters.enclosure.pwl

import acumen.interpreters.enclosure.Parameters
import acumen.interpreters.enclosure.Interval
import acumen.interpreters.enclosure.tree.Field
import acumen.interpreters.enclosure.Box
import acumen.interpreters.enclosure.Types._
import acumen.interpreters.enclosure.UnivariateAffineEnclosure
import acumen.interpreters.enclosure.tree.SolveIVP
import acumen.interpreters.enclosure.Rounding
import acumen.interpreters.enclosure.tree.HybridSystem

trait Strategy extends EncloseEvents with SolveIVP {

  def eventSegment(ps: Parameters, h: HybridSystem, t: Interval, b: Box, m: Mode)(implicit rnd: Rounding): (Set[UncertainState], Seq[UnivariateAffineEnclosure]) = {
    val gs = //  the guards of events starting in m 
      h.events.filter(e => e.sigma == m).map(h.guards(_))
    val es = piecewisePicard(ps, h.fields(m), t, b)
    val (before, rest) = // before any events and the rest 
      es.span(e => { val ran = e.range; !gs.exists(g => g(ran).contains(true)) })
    if (rest.isEmpty) // no events possible, return flow for all of t 
      (Set(UncertainState(m, before.last(t.high))), before)
    else {
      // TODO: localize left end-point using prefix of rest
      // TODO: localize right end-point using suffix of during
      val d = h.domains(m)
      val (during, after) = rest.span(e => d(e(e.domain.high)).contains(true))
      val left =
        if (before.isEmpty) t.low
        else before.last.domain.high
      val init =
        if (left == t.low) emptyState(h) + (m -> Some(b))
        else emptyState(h) + (m -> Some(before.last(left)))
      val right = if (after.isEmpty) t.high else after.head.domain.high
      val (s, fin) = encloseEvents(ps, h, left /\ right, init)
      (uncertainStates(fin), before ++ enclosures(left /\ right, s))
    }
  }

  /**
   * Uses the output of trisect to further localize the first event. Returns the sub-interval
   * of the union of the domains of `during` and `after` that starts before the first event
   * and, if possible, ends after the first event.
   */
  def localize(during: Seq[UnivariateAffineEnclosure], after: Seq[UnivariateAffineEnclosure]): Interval = {
	  
  }

  /**
   * `before` is a solution to the IVP in mode `m`
   * `during` defines an interval where the first event in `t` can occur
   * `after` defines a possibly empty of times before which the first event must have occurred
   */
  def trisect(ps: Parameters, h: HybridSystem, t: Interval, b: Box, m: Mode)(implicit rnd: Rounding): (Seq[UnivariateAffineEnclosure], Seq[UnivariateAffineEnclosure], Seq[UnivariateAffineEnclosure]) = {
    val gs = //  the guards of events starting in m 
      h.events.filter(e => e.sigma == m).map(h.guards(_))
    val es = piecewisePicard(ps, h.fields(m), t, b)
    val (before, rest) = // before any events and the rest 
      es.span(e => { val ran = e.range; !gs.exists(g => g(ran).contains(true)) })
    val d = h.domains(m)
    val (during, after) = rest.span(e => d(e(e.domain.high)).contains(true))
    (before, during, after)
  }

  // TODO add callback parameter and hook into plotter at the HEREs below 
  def piecewisePicard(ps: Parameters, f: Field, t: Interval, b: Box)(implicit rnd: Rounding): Seq[UnivariateAffineEnclosure] = {
    if (t.width greaterThan ps.maxTimeStep) repeatPiecewisePicard(ps, f, t, b)
    else {
      val e = solveVt(f, t, b, ps.solveVtInitialConditionPadding, ps.picardImprovements, ps.maxPicardIterations, ps.splittingDegree)
      if (t.width lessThan ps.minTimeStep * 2) Seq(e) // HERE
      else {
        val (tL, tR) = t.split
        val eL = solveVt(f, tL, b, ps.solveVtInitialConditionPadding, ps.picardImprovements, ps.maxPicardIterations, ps.splittingDegree)
        val bR = eL(tL.high)
        val eR = solveVt(f, tR, bR, ps.solveVtInitialConditionPadding, ps.picardImprovements, ps.maxPicardIterations, ps.splittingDegree)
        if (norm(e(t.high)) - norm(eR(t.high)) lessThan ps.minComputationImprovement) Seq(e) // HERE
        else repeatPiecewisePicard(ps, f, t, b)
      }
    }
  }

  /** The method formerly known as bisectAndRecur */
  def repeatPiecewisePicard(ps: Parameters, f: Field, t: Interval, b: Box)(implicit rnd: Rounding): Seq[UnivariateAffineEnclosure] = {
    val (tL, tR) = t.split
    val esL = piecewisePicard(ps, f, tL, b)
    val bR = esL.last(tL.high)
    val esR = piecewisePicard(ps, f, tR, bR)
    esL ++ esR
  }

}
