
Typical interpreter structure

- ast    - acumen.AST *
- env    - standard.interpreter.Env *
           original.interpreter.Env
- store  - acumen.interpreters.imperative.Object (mutable)
           acumen.reference.original.interpreter.CStore (immutable)
- errors - acumen.Errors *
- eval   -

o ::= self | n
x ::= o.n
e ::= constants, vectors, summations, ...
s ::= x'=e | x:=e | if e s else s end | let x=e in s end
    | create C(e*) | move ... | terminate ...
    | for ...
    | report error "..." // new construct
d ::= class C(x*) private s* end s* end
     
Syntactic sugar (taken care of by a preprocessor):
  - switch -> if + error
  - D ::= x | D'
  - D'=e -> y'=e, D=y, and replace D' everwhere with y'
    - Formally, D' is x'(n+1), and with notation D is just x'(n) 
  - D':=e -> y:=e, D'=y, and replace D' everywhere with y.
  - // anything else that came up from the recent paper?

Semantics
  - All discrete assignments should be done in paralell
    - Repeat until a fixed point is reached.
    - This should set higher derivatives to undefined
    - Any duplicates are an error
  - All integations should be done in parallel
    - Any duplicates are an error
    - Here we should (semantically) check there are no undefined
      variables.
  - Ad hoc choice:  All discrete, then all parallel.
  - Lets are always done afresh on any iterations
    - This should preserve the exact substitution property
