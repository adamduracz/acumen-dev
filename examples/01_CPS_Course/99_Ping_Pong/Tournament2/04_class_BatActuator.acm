/**
* Actorator for moving the bat, which also keeps track of the energy spent.
**/

model BatActuator(n,p1,tablerow,tablecolum,maxE) = 
initially
  p        =  p1,
  p'       =  (0,0,0),
  a        =  (0,0,0),
  angle    =  (0,0,0),
  energy   =  0,
  energy'  =  0,
  // Mass of the bat
  m  =  0.1,
  F  =  0,
  mode  =  "Sample",
  v     =  (0,0,0), 
  // Visualize energy spent
  eb   =  create cylinder((0,0,0),tablerow,tablecolum),
  offset  =  0,
  link1  =  create cylinder((0,0,0),tablerow,tablecolum),
  link2  =  create cylinder((0,0,0),tablerow,tablecolum),
  L1     =  0.4,  // Length of link1 is fixed
  baseP  =  (2.4*(-1)^n,0,0.3),
  unit   =  (0,0,0), // Unit vector from baseP to P
  timer  =  0,       // timer for BatActuator
  timer' =  1
always
  match mode with [
    "Sample" -> 
      v + == p',
      mode + == "Wait"
  | "Wait" ->
      timer' = 1,
      if timer >= 0.01 then
        mode + == "Calculate"
      noelse
  | "Calculate" ->
      a + == (p' - v)/timer,
      timer + == 0,
      mode + == "Sample"
  ],
   
  F = m * norm(a),
  if norm(p') > 5 then // ???Saturate??? speeds over 5
    p' + == p'/norm(p') * 5 
  noelse,
  energy' = F * norm(p'), // Simplistic model of power consumed
  // Visualize arm
  unit = (p - baseP)/norm(p - baseP),
  link1.q = baseP,
  link1.p = baseP + L1 * unit,
  link1.r = 0.1,
  link2.q = link1.p,
  link2.p = p +  ((-1)^n * 0.05,0,0),
  link2.r = 0.03,
  // Energy bar visualization
  offset = (energy/maxE)*1.5,
  eb.p = ((-1)^n * 1.5, -0.8, -0.05),
  eb.q = ((-1)^n * 1.5 + (-1)^(n+1) * offset, -0.8, -0.05),
  eb.r = 0.02,
  eb.col = (0.2,1,0.2)