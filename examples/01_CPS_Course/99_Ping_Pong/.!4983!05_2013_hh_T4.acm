// Model   :  2013_hh_T4.acm.  Practice game (3-D Ping Pong) 
// Author  :  Yingfu Zeng, Walid Taha, Xu Fei
// Date    :  2012/02/11
// Revision:  2013/02/06 New syntax for assignments (= and :=)
// Ideas   :  Bat has no mass.  Focus is on: Impact,  
//            problem decomposition, and systems modeling
// License:   BSD, GPL(V2), or other by agreement with Walid Taha

/* 
   Has error with semantic 2014
   Works with semantic 2013
   Has bug with semantic 2012
*/

#semantics "2013 Reference"

class Pawanism(n,maxA)
  private
    name      := "Pawanism";
    varX      := 0;
    varZ      := 0;
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.25*(-1)^n;
    zp        := 3;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 20 + 10 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.3,0.4];

         if(t < ta)
          v' = maxA* u;
          angle_bat' = (a_desired - angle_bat)/ta;
         // angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
          angle_bat = a_desired;
        else if (norm(p_ball - p_bat)>0.3)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.3)
          v' = [(-1)^(n+1)*5-v(0),0,8-v(2)];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.25*atan(p1_predicted(1)/p1_predicted(0)) + (-1)^(n+1)*atan(v1_predicted(1)/v1_predicted(0)),0.4];
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0.1   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat' = (a_desired - angle_bat)/ta;
      //angle_bat = a_desired;
      if(t < ta)
        
        v' = maxA* u;
       

      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =10*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        varX = 50*(abs(p_ball(0)))-norm(v_ball)*15;
        varZ = varX;     
        v' = [(-1)^(n+1)*varX-v(0),0,varZ-v(2)];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
 
  r'' = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  theta'' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y));
 
end

class Dexter(n,maxA)
private
name := "Dexter";
mode := "Wait"; // Initial mode is to Wait
bounced := false; // Has the ball bounced?
myServe := false; // Your turn to serve? (set by Parent)
starting := false; // Your turn to start the ball? (set by Parent)
v_ball := [0,0,0]; // Ball velocity (set by Parent)
p_ball := [0,0,0]; // Ball position (set by Parent)
p_bat := [1.6*(-1)^n,0,0.2]; // Bat position (set by Parent)
v := [2.828,0.5,1.414]; // Bat velocity
v' := [0.5,0.5,-0.866]; // Bat accerleration
// The y position and velocity in z axis player can set to start the ball
yS := 0.435*(-1)^n;
zp := 4;
pH := [0,0,0]; // Heightest point of my start ball
angle_bat := [0.235,0.5,-0.866]; // Normal vector of the bat's plane
angle_bat' := [0,0,0];
a_desired := [0.9471*(-1)^(n+1),0,0.4];
v_desired := [1.6*(1)^n,0,1.2];
// local timer
t := 0;
t' := 1;
// These coefficients are needed for prediction of ball movement
// Coefficient of restitution
k_z := [1.0, 1.0, -0.99];
// Coeffiecent of air resistance
k_a := -1/6;
// Ball acceleration (predicted)
a1_predicted := [0.0, 0.0, -9.8];
a2_predicted := [0.0, 0.0, -9.8];
// First prediction poit: time, position, speed
// When ball hits the table
t1_predicted := 0;
p1_predicted := [0, 0, 0];
v1_predicted := [0, 0, 0];
// Second prediction point: time, position, speed
// The maximum point of the second parabola
t2_predicted := 0;
p2_predicted := [0, 0, 0];
v2_predicted := [0, 0, 0];
doneOnce := false;
// Time for accelerating
ta := 0;
// Time for decelerating
td := 0;
// Unit vector of direction
u := [1,0,0];
// Distance between goal point and batp
d_ballBat := 0;
// Prediction pointers (for debugging)
_3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
// Spherical coordinate system
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
end
if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
mode := "Panic!";
end;
t' = 1; // Rate for local timer
// pH is the hightest from my start ball(easy to calculate from y and zp)
pH := [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 + k_a*(zp)^2));
a = -9.8 + k_a*(zp)^2 in
zp*t + 0.5 * (a)*t^2 end];
switch mode
case "Wait" // Waiting for your serve, moving the bat to start point
v' = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
t := 0;
t1_predicted := 0;
t2_predicted := 0;
p2_predicted := [0,0,0];
doneOnce := false;
angle_bat' = 2*([0,0,0] - angle_bat);
if myServe == true && starting == false
mode := "Prepare";
end;
// Calculate how to get to goal point(slightly behind and below pH)
if myServe == true && starting == true
t := 0;
d_ballBat := norm(p_bat - pH);
u := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
mode := "Startball";
end;
case "Startball" // Start the ball as I wanted
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
// Path planning, first half distance fully accelerate the other
// half fully decelerate
if(t < ta)
v' = maxA* u;
angle_bat = [0.9471*(-1)^(n+1),0,0.7];
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.25)
v' =10*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.25)
v' = [-7 * (p_ball(0)),0,7];
ta := 0;
end;
end;
end;
end;
case "Prepare" // Prepare to hit the ball
//Do predict, and move pat towards the second predict point
// Bouncing condition
if (p_ball(2)) < 0 && bounced == false
bounced := true;
end;
if bounced == true
p1_predicted = p_ball;
v1_predicted = v_ball;
t1_predicted = 0;
else
// Calculating first prediction point
// Linearized air resistance
a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
// 1/a in z direction
t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2)) // -v0
- sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
// Check if ball is going out of bounds
// We can predict this before it actually happens
// This actually can decrease power consuption in some cases.
if t > 0.2*abs(t1_predicted)
if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0
|| abs((p1_predicted(1))) > 0.78
mode := "Wait";
myServe := false;
end;
end;
end;
// Predict the goal point to prepare hit the ball(only do once per turn)
if (t1_predicted < 0.15 && t1_predicted ~= 0) &&
((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
doneOnce == false
// Calculating second prediction point
// Linearized air resistance
a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted *
(t2_predicted^2);
v2_predicted = p1_predicted + a2_predicted * t2_predicted;
doneOnce := true;
// First move back a bit
// Save 0.05 sec for hit the ball with calculated velocity and angle
t2_predicted := t2_predicted - 0.05;
t := 0;
ta := t2_predicted/2;
u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
end;
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
if doneOnce == false
v' = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
end;
// Path planning, first move to p2, then wait to hit the ball
if doneOnce == true
ta := sqrt(2* (d_ballBat/2)/maxA);
angle_bat = a_desired;
if(t < ta)
v' = maxA* u;
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.2)
v' =5*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)
v' = [-30*(p_ball(0)),0,20];
ta = 0;
end;
end;
end;
end;
end;
case "Reset" // Reset the intermediate variables to its initial value
p_bat := [1.6*(-1)^n,0,0.2];
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
v := [0,0,0]; v' := [0,0,0];
mode := "Wait";
case "Panic!"
end;
x'' = (v'(0));
y'' = (v'(1));
z'' = (v'(2));

/*
r'' = 0; // Derive correct equation
alpha '' = 0; // Derive correct equation
theta '' = 0; // Derive correct equation
end
*/


 r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')-(r'^2))/r; 

alpha''= ((z*r''-z''*r)/((r)*(x^2+y^2)^(1/2)))-((r'*alpha')/r)-(((x*x'+y*y')*alpha'))/(x^2+y^2);

theta'' =((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/(x^2+y^2);

end


class Joshua(n,maxA)
  private
    name      := "Joshua";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    a_d  := [0,0,0];
    v_desired  := [3*(1)^n,1,0];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];


    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];


    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
 switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
  
      v'  = ([(1.6*(-1)^n-p_bat(0)),0-p_bat(1),0.2-p_bat(2)] ) * 85 + 20 * ([0,0,0]- v);
  
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t := 0;  
        d_ballBat := norm(p_bat - pH);
        u := (pH + [0.07*(-1)^n,0,-0.1] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.1] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2* (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        if starting == false
           mode := "Prepare";
        end;
        if(t < ta)
          v' = maxA* u;       
          angle_bat' = (a_desired - angle_bat)/ta; 
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;
          angle_bat = a_desired+[0,pi/7*(-1)*(-1)^n,0]; 
        else if (norm(p_ball - p_bat)>0.2)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.2)
            v' = [-10 * (p_ball(0)),0,5];
            ta := 0;    
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball and do the predict
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.53 || (p1_predicted(0))*(-1)^n < 0.2   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
          end;
      end;


      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
         if abs(p1_predicted(0))>1
           t2_predicted = -0.6*/*abs(p1_predicted(1))*/(v1_predicted(2)) / (a2_predicted(2));
         else
           t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
         end;
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = v1_predicted + a2_predicted * t2_predicted;
      doneOnce := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
       if abs(p1_predicted(0))<0.2
       u=[0,0,0];
       else
      u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 5 + 5 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      if p2_predicted(2)>0.4
      
        a_d =[0,-p2_predicted(1)*pi/7,-p2_predicted(2)*pi/15]
      else
       a_d = [0,-p2_predicted(1)*pi/7,-v2_predicted(2)*pi/20];
      end;
       angle_bat' = (a_desired+ a_d - angle_bat)/ta;
      if (norm(p_ball - p_bat)>0.2)
      v'  = (p2_predicted + [0.2*(-1)^n,0,0] - p_bat) * 85 + 20 * ([0,0,0]- v);
      else if (norm(p_ball - p_bat)<0.2)
        if abs(p2_predicted(0))>1.5
        v' = -100*(v-1*[-0.9*abs(p2_predicted(0))*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        else if abs(p2_predicted(0))>1.2
        v' = -100*(v-1*[-1.6*abs(p2_predicted(0))*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);//+5*(0.5*v_desired-v);
        else
         v' = -100*(v-1*[-3*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        end;
        ta = 0;
//     end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  r''      = (2*x'^2 + 2*y'^2 + 2*z'^2 + 2*x*x'' + 2*y*y'' + 2*z*z'')/(2*(x^2 + y^2 + z^2)^(1/2)) 
              - (2*x*x' + 2*y*y' + 2*z*z')^2/(4*(x^2 + y^2 + z^2)^(3/2));
  alpha '' = -1 * (z''/r - (2*r'*z')/r^2 + (2*z*r'^2)/r^3 - (z*r'')/r^2)/(1 - z^2/r^2)^(1/2) 
             - ((z'/r - (z*r')/r^2)*((2*z*z')/r^2 - (2*z^2*r')/r^3))/(2*(1 - z^2/r^2)^(3/2));
  theta '' = (x''*y-x*y'')/(y^2+x^2)-(x'*y-x*y')*(2*y*y'+2*x*x')/((y^2+x^2)^2);

end

class TheAvengers(n,maxA)
  private
    name      := "Avengers";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r)-((x*x'+y*y'+z*z')^2/r^3); // Derive correct equation
  alpha '' = -1*((z''/r)-((2*x*x'+2*y*y'+2*z*z')*z'/r^3)-(z*(x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r^3) +(3*z*(x*x'+y*y'+z*z')^2/r^5))/((x^2+y^2)/r^2)^0.5 -(z*(x^2*z'-z*x*x'+y^2*z'-z*y*y')^2/((x^2+y^2)^1.5*r^4));
  theta '' = -1*(x*(y*(2*x'^2-2*y'^2)+y^2*y'')-x^2*(y*x''+2*y'*x')+x^3*y''-y^3*x''+2*y^2*x'*y')/((x^2+y^2)^2);

end


class LPD(n,maxA)
private
name := "PlayerLPD";
mode := "Wait"; // Initial mode is to Wait
bounced := false; // Has the ball bounced?
myServe := false; // Your turn to serve? (set by Parent)
starting := false; // Your turn to start the ball? (set by Parent)
v_ball := [0,0,0]; // Ball velocity (set by Parent)
p_ball := [0,0,0]; // Ball position (set by Parent)
p_bat := [1.6*(-1)^n,0,0.2]; // Bat position (set by Parent)
v := [0,0,0]; // Bat velocity
v' := [0,0,0]; // Bat accerleration 
// The y position and velocity in z axis player can set to start the ball
yS := 0.5*(-1)^n;
zp := 4;
pH := [0,0,0]; // Heightest point of my start ball
angle_bat := [0,0,0.001]; // Normal vector of the bat's plane
angle_bat' := [0,0,0];
a_desired := [0.9471*(-1)^(n+1),0,0.4];
v_desired := [1.6*(1)^n,0,1.2];
// local timer
t := 0;
t' := 1;
// These coefficients are needed for prediction of ball movement
// Coefficient of restitution
k_z := [1.0, 1.0, -0.99];
// Coeffiecent of air resistance
k_a := -1/6;
// Ball acceleration (predicted)
a1_predicted := [0.0, 0.0, -9.8];
a2_predicted := [0.0, 0.0, -9.8];
// First prediction poit: time, position, speed
// When ball hits the table
t1_predicted := 0;
p1_predicted := [0, 0, 0];
v1_predicted := [0, 0, 0]; 
// Second prediction point: time, position, speed
// The maximum point of the second parabola
t2_predicted := 0;
p2_predicted := [0, 0, 0];
v2_predicted := [0, 0, 0];
doneOnce := false;
// Time for accelerating
ta := 0;
// Time for decelerating
td := 0;
// Unit vector of direction
u := [1,0,0];
// Distance between goal point and batp
d_ballBat := 0;
// Prediction pointers (for debugging)
_3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
// Spherical coordinate system
r := norm([1.6,0.1,0.2]); 
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1); 
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1;    y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0; 
end
if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
mode := "Panic!";
end;
t' = 1; // Rate for local timer
// pH is the hightest from my start ball(easy to calculate from y and zp) 
pH := [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 + k_a*(zp)^2));
a = -9.8 + k_a*(zp)^2 in
zp*t + 0.5 * (a)*t^2 end];
switch mode
case "Wait" // Waiting for your serve, moving the bat to start point
v' = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
t := 0;
t1_predicted := 0;
t2_predicted := 0;
p2_predicted := [0,0,0];
doneOnce   := false;
angle_bat' = 2*([0,0,0] - angle_bat);
if myServe == true && starting == false
mode := "Prepare";
end;
// Calculate how to get to goal point(slightly behind and below pH)
if myServe == true && starting == true
t := 0; 
d_ballBat := norm(p_bat - pH); 
u := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
mode := "Startball";
end;
case "Startball" // Start the ball as I wanted
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
// Path planning, first half distance fully accelerate the other
// half fully decelerate
if(t < ta)
v' = maxA* u;
angle_bat = [0.9471*(-1)^(n+1),0,0.7]; 
else if (t>=ta && t<2*ta)
v' = -maxA * u; 
else if (norm(p_ball - p_bat)>0.25)
v' =10*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.25)
v' = [-7 * (p_ball(0)),0,7];
ta := 0; 
end;
end;
end;
end;
case "Prepare" // Prepare to hit the ball
//Do predict, and move pat towards the second predict point 
// Bouncing condition
if (p_ball(2)) < 0 && bounced == false
bounced := true;
end;
if bounced == true
p1_predicted = p_ball;
v1_predicted = v_ball;
t1_predicted = 0;
else
// Calculating first prediction point
// Linearized air resistance
a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
// 1/a in z direction
t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2)) // -v0
- sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
// Check if ball is going out of bounds
// We can predict this before it actually happens
// This actually can decrease power consuption in some cases.
if t > 0.2*abs(t1_predicted)
if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0 
|| abs((p1_predicted(1))) > 0.78
mode := "Wait";
myServe := false;
end;
end; 
end;
// Predict the goal point to prepare hit the ball(only do once per turn)
if (t1_predicted < 0.15 && t1_predicted ~= 0) &&
((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
doneOnce == false
// Calculating second prediction point
// Linearized air resistance
a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * 
(t2_predicted^2);
v2_predicted = p1_predicted + a2_predicted * t2_predicted;
doneOnce := true;
// First move back a bit
// Save 0.05 sec for hit the ball with calculated velocity and angle
t2_predicted := t2_predicted - 0.05;
t := 0;
ta := t2_predicted/2;
u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
end;
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
if doneOnce == false
v' = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
end;
// Path planning, first move to p2, then wait to hit the ball 
if doneOnce == true
ta := sqrt(2* (d_ballBat/2)/maxA);
angle_bat = a_desired;
if(t < ta)
v' = maxA* u;
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.2)
v' =5*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)
v' = [-30*(p_ball(0)),0,20];
ta = 0;
end;
end;
end;
end;
end;
case "Reset" // Reset the intermediate variables to its initial value
p_bat := [1.6*(-1)^n,0,0.2];
r := norm([1.6,0.1,0.2]); 
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1); 
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0; 
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
v := [0,0,0]; v' := [0,0,0];
mode := "Wait";
case "Panic!"
end;
x'' = (v'(0));
y'' = (v'(1));
z'' = (v'(2));

r'' = 1.02*(1/r)*(x*x''+y*y''+z*z''+x'*x'+y'*y'+z'*z')- (r')^2;
alpha''=-1.2*(y''*x-y*x'')/(x^2+y^2)+ ((y'*x-y*x')*(2.01*x*x'+2*y*y'))/((x^2+y^2)^2)*1.01;
theta '' =(x''*y-x*y''+(2.03*alpha')*(z*z'-r*r'))/(r^2-z^2)*1.02;
end 

class Wallace(n,maxA)
  private
    name      := "Wallace";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.65*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =20*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z))); // Derive correct equation
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z))); // Derive correct equation
  theta '' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y)); // Derive correct equation

end

class Wallace1(n,maxA)
  private
    name      := "wallace";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/5.6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = ((-r'/r^2)*(x*x'+y*y'+z*z'))+((x'/r)*(x*x''+x'))+((y'/r)*(y*y''+y'))+((z'/r)*(z*z''+z')); // Derive correct equation
  alpha '' = (y*x''-x*y''-2*(x*x'+y*y')*theta')/(x^2+y^2); // Derive correct equation
  theta '' = ((x'/(x^2+y^2)^2)*((2*x*x'*y)-(x^2+y^2)*(x''*y)+(x^2+y^2)*(y')-(x*y')*(2*x)))+((y'/((x^2+y^2)^2))*((2*(x')*y^2)-((x^2+y^2)*(x'))+((x*y'')*(x^2+y^2))-(2*x*y*y'))); // Derive correct equation

end

class Swastik(n,maxA)
  private
    name      := "Swastik";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (x*x''+(x')^2+y*y''+(y')^2+z*z''+(z')^2-(r')^2)/r; 
 alpha'' = (r*sqrt(r^2-z^2)*(z*r''-z''*r)-(z*r'-z'*r)*((2*r*(r^2-z^2)^(-1/2)*(r*r'-z*z')+sqrt(r^2-z^2)*r')))/((r^2)*(r^2-z^2)); 
theta'' = (y*x''-x*y''-2*(x*x'+y*y')*alpha')/(x^2+y^2); 
end

class Sparta(n,maxA)
 private
   name      := "sparta";
   mode      := "Wait";   // Initial mode is to Wait
   bounced   := false;    // Has the ball bounced?
   myServe   := false;    // Your turn to serve?  (set by Parent)
   starting  := false;    // Your turn to start the ball? (set by Parent)
  v_ball    := [0.3535/(n+4),0.3535,0.5];      // Ball velocity (set by Parent)
   p_ball    := [ 0,0,0 ];      // Ball position (set by Parent)
   p_bat     := [1.6*(-1)^n,0.20,0.4];  // Bat  position (set by Parent)
   v         := [0.3535/(n+4),0.3535,0.5];      // Bat velocity
   v'        := [ 0 , 0 , 0 ];      // Bat accerleration
   // The y position and velocity in z axis player can set to start the ball
   yS        :=((-1)^n)*0.772;
   zp        := 4.5;
   pH        := [0,0,0];  // Heightest point of my start ball
   angle_bat  := [0,sin(pi/6),cos(7*pi/12)*(-1)^(n-1)];  // Normal vector of the bat's plane
  angle_bat' := [0,0,0];
   a_desired  := [0.9471*(-1)^(n+1),0,0.4];
   v_desired  := [1.6*(1)^n,0,1.2];
   // local timer
   t    := 0;
  t'   := 1;
   // These coefficients are needed for prediction of ball movement
   // Coefficient of restitution
   k_z := [1.0, 1.0, -0.99];
   // Coeffiecent of air resistance
   k_a := -1/6;

   // Ball acceleration (predicted)
   a1_predicted  := [0.0, 0.0, -9.8];
   a2_predicted  := [0.0, 0.0, -9.8];
   // First prediction poit: time, position, speed
   // When ball hits the table
   t1_predicted  := 0;
   p1_predicted  := [0, 0, 0];
   v1_predicted  := [0, 0, 0];
   // Second prediction point: time, position, speed
   // The maximum point of the second parabola
   t2_predicted  := 0;
   p2_predicted  := [0, 0, 0];
   v2_predicted  := [0, 0, 0];
   doneOnce   := false;
   // Time for accelerating
  ta         := 0;
   // Time for decelerating
   td         := 0;
   // Unit vector of direction
   u          := [1,0,0];
   // Distance between goal point and batp
   d_ballBat  := 0;
   // Prediction pointers (for debugging)
   _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],

          ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

   // Spherical coordinate system

   r      := norm([1.6,0.1,0.2]);   

   r'     := 0;                     r''     := 0;

   alpha  := acos(0.2/norm([-1.6,0.1,0.2]));

   alpha' := 0;                     alpha'' := 0;

   theta  := atan(1.6*(-1)^n/0.1);  

   theta' := 0;                     theta'' := 0;

   x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;

   y  := 0.1;          y' := 0;     y''     := 0;

   z  := 0.2;          z' := 0;     z''     := 0;

 end

 

 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"

    mode := "Panic!";

 end;

 

 t'  = 1;   // Rate for local timer

 // pH is the hightest from my start ball(easy to calculate from y and zp)   

 pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));

                             a = -9.8 +  k_a*(zp)^2 in

                   zp*t + 0.5 * (a)*t^2 end];

 switch mode

   case "Wait" // Waiting for your serve, moving the bat to start point

     v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);

     t   := 0;

     t1_predicted  := 0;

     t2_predicted  := 0;

     p2_predicted  := [0,0,0];

     doneOnce      := false;

     angle_bat'     = 2*([0,0,0] - angle_bat);

     if myServe == true && starting == false

       mode := "Prepare";

     end;

     // Calculate how to get to goal point(slightly behind and below pH)

     if myServe == true && starting == true

       t  := 0;  

       d_ballBat := norm(p_bat - pH);

       u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);

       ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;

       mode := "Startball";

     end;

   case "Startball" // Start the ball as I wanted

       _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],

               ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];

       

       // Path planning, first half distance fully accelerate the other

       // half fully decelerate

        if(t < ta)

         v' = maxA* u;

         angle_bat = [0.9471*(-1)^(n+1),0,0.7];     

       else if (t>=ta && t<2*ta)

         v' = -maxA * u;          

       else if (norm(p_ball - p_bat)>0.25)

         v' =10*([0,0,0]-v);

       // Prepare to hit the ball

       else if (norm(p_ball - p_bat)<0.25)

         v' = [-7 * (p_ball(0)),0,7];

         ta := 0;      

       end;

       end;

       end;

     end;

   case "Prepare"    // Prepare to hit the ball

     //Do predict, and move pat towards the second predict point

     // Bouncing condition

     if (p_ball(2)) < 0 && bounced == false

       bounced := true;

     end;

     if bounced == true

       p1_predicted  = p_ball;

       v1_predicted  = v_ball;

       t1_predicted  = 0;

     else

       // Calculating first prediction point

       // Linearized air resistance

       a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball

       // 1/a in z direction

       t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0

                      - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));

       p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);

       v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;

       // Check if ball is going out of bounds

       // We can predict this before it actually happens

       // This actually can decrease power consuption in some cases.

       if t > 0.2*abs(t1_predicted)

         if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   

            || abs((p1_predicted(1))) > 0.78

           mode    := "Wait";

           myServe := false;

         end;

       end;

     end;

     // Predict the goal point to prepare hit the ball(only do once per turn)

     if (t1_predicted < 0.15 && t1_predicted ~= 0) &&

        ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&

        doneOnce == false

     // Calculating second prediction point

     // Linearized air resistance

     a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;

     t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));

     p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);

     v2_predicted = p1_predicted + a2_predicted * t2_predicted;

     doneOnce    := true;

     // First move back a bit

     // Save 0.05 sec for hit the ball with calculated velocity and angle

     t2_predicted := t2_predicted - 0.05;

     t  := 0;

     ta := t2_predicted/2;

     u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);

     d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);

     end;

     _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],

             ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];

     

   if doneOnce == false

     v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);

   end;

   // Path planning, first move to p2, then wait to hit the ball

   if doneOnce == true

     ta := sqrt(2* (d_ballBat/2)/maxA);

     angle_bat = a_desired;

     if(t < ta)

       v' = maxA* u;

     else if (t>=ta && t<2*ta)

       v' = -maxA * u;

     else if (norm(p_ball - p_bat)>0.2)

       v' =5*([0,0,0]-v);

     // Prepare to hit the ball

     else if (norm(p_ball - p_bat)<0.2)

       v' = [-30*(p_ball(0)),0,20];

       ta = 0;

     end;

     end;

     end;

     end;

   end;

   case "Reset"  // Reset the intermediate variables to its initial value

     p_bat := [1.6*(-1)^n,0,0.2];

     r      := norm([1.6,0.1,0.2]);   

     r'     := 0;                     r''     := 0;

     alpha  := acos(0.2/norm([-1.6,0.1,0.2]));

     alpha' := 0;                     alpha'' := 0;

     theta  := atan(1.6*(-1)^n/0.1);  

     theta' := 0;                     theta'' := 0;

     x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;

     y  := 0.1;          y' := 0;     y''     := 0;

     z  := 0.2;          z' := 0;     z''     := 0;

     v := [0,0,0];       v' := [0,0,0];

     mode := "Wait";

   case "Panic!"

 end;

 x'' = (v'(0));

 y'' = (v'(1));

 z'' = (v'(2));

 r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')-(r'^2))/r;      // Derive correct equation
theta'' =((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/(x^2+y^2);
alpha''= ((z*r''-z''*r)/((r)*(x^2+y^2)^(1/2)))-((r'*alpha')/r)-(((x*x'+y*y')*alpha'))/(x^2+y^2);
end


//PingWee 0.4
/*
A sraight port of our previous player.
We removed the moving average filter since it did not seem to affect the our player noticeably.
Derivatives of r, alpha and theta were computed on paper with help and verification by Wolfram alpha.
Minor tweaks in the computation of force needed for return.

Regrettably it seems we wont have time to implement two features that we have wanted to include from the start
-catching the ball by the table edge if the peak of the trajectory is too far away
-reverse-engineering the prediction formulas to be able to predict the force needed to make optimal shots
*/
class PeeWee(n,maxA)
  private /*------------------------- Privates -------------------------*/
    name      := "PeeWee";
    mode      := "Wait";
    bounced   := false;

    //Inputs (set by parent)
    myServe   := false; starting  := false; // Your turn to hit or start
    v_ball    := [0,0,0]; p_ball := [0,0,0]; // Ball velocity/position
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position
    
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat acceleration
    
    // Starting ball parameters
    yS := 0.5*(-1)^n; zp := 4.0; pH := [0,0,0];  //y position, z-speed, Declare: Heightest point; of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
    
    // local timer
    t := 0; t' := 1;
    
    // These coefficients are needed for prediction of ball movement
    k_z := [1.0, 1.0, -0.99]; // Coefficient of restitution
    k_a := -1/6; // Coeffiecent of air resistance
    a1_predicted  := [0.0, 0.0, -9.8]; a2_predicted  := [0.0, 0.0, -9.8]; // Ball acceleration (predicted)
      
    // Prediction points: time, position, speed
    // When ball hits the table
    t1_predicted  := 0; p1_predicted  := [0, 0, 0]; v1_predicted  := [0, 0, 0];
    // The maximum point of the second parabola
    t2_predicted  := 0; p2_predicted  := [0, 0, 0]; v2_predicted  := [0, 0, 0];
    // The point where the ball passes our board edge
    t3_predicted  := 0; p3_predicted  := [0, 0, 0]; v3_predicted  := [0, 0, 0];
    
    doneOnce   := false;
    Iterate := 0;
    firstStartBall := true;
    
    // Declare: Time for accelerating, decelerating
    ta := 0;  td := 0;
    u := [1,0,0]; // Unit vector of direction
    d_ballBat  := 0; // Declare: Distance between goal point and batp
    
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ,["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ,["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ];
    
    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
    
    
  end /*------------------------- Code -------------------------*/
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
     Iterate := 0;
  end;
  
  // pH is the hightest point of the startball before hitting it, used by Startball mode
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));    a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  
  //This comment was written to commemorate the loss of the AVG function. Rest in peace.
  
  switch mode
    case "Wait" /*------------------------- Wait -------------------------*/
      Iterate = Iterate +1;
      
      t := 0; //reset variables
      t1_predicted := 0; t2_predicted := 0; t3_predicted := 0;
      p1_predicted := [0,0,0]; p2_predicted := [0,0,0]; p3_predicted := [0,0,0];
      doneOnce      := false;
      angle_bat'     := 2*(a_desired - angle_bat);
      
      if myServe == true && starting == false
        mode := "Prepare";
        Iterate := 0;
      
      else if myServe == true && starting == true
        // Calculate how to get to goal point(slightly behind and below pH)
        t := 0;
        d_ballBat := norm(p_bat - pH);
        u := (pH + [0.07*(-1)^n,0,-0.1] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat); //Direction we want to move
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2* (d_ballBat / 2) / maxA) end;
        mode := "Startball";
        Iterate := 0;
      
      else //Do while waiting
        v'  := ([1.5*(-1)^n, 0.5*p_ball(1), 0.3] - p_bat) * 8 + 2 * ([0,0,0]- v); //Follow the ball in y, dampen speed
        //v'  := 5 * ([0,0,0]- v); //Follow the ball in y, dampen speed
        //Idea:
        //Predict the y-position where the ball reaches the other end of the table and move there?
        
      end;
      end;
      
    case "Startball" /*------------------------- Startball -------------------------*/
      Iterate = Iterate +1;
      
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]]
             ,["Sphere",pH,0.02,[0,100,200],[0,0,0]]
             ];
      
      if(myServe == false || starting == false) //If this then we really shouldn't be here
        mode := "Wait";
        Iterate := 0;
      end;
      
      // Path planning, first half distance fully accelerate the other 
      // half fully decelerate
      if(t < ta) //Move to starting point?
        v' = maxA* u;

        //angle_bat = [0.9471*(-1)^(n+1),0,0.7]; //Default
        
        a_desired = [0.9471*(-1)^(n+1), -(p_ball(1)*0.65), 0.4];
        angle_bat' = (a_desired - angle_bat)/ta; 
      else if (t>=ta && t<2*ta) //Stop at starting point?
        v' = -maxA * u;
        angle_bat = a_desired; 
      else if (norm(p_ball - p_bat)>0.25) //Does nothing? Does not trigger?
        //v' =10*([0,0,0]-v); //Default
        v' =5*([0,0,0]-v);
      else if (norm(p_ball - p_bat)<0.25)
        if(firstStartBall == true) //To adjust the first-of-the-game startball
          v' = [-6.5 * (p_ball(0)), -p_ball(1)*0, (4-p_ball(2))*3.8];
        else
          //v' = [-7 * (p_ball(0)),0,7]; //Default
          v' = [-14.5 * (p_ball(0)), -p_ball(1)*0, (4-p_ball(2))*5.5];
        end;
        ta := 0;
      end;end;end;end;
      
      
    case "Prepare" /*------------------------- Prepare -------------------------*/
      Iterate = Iterate +1;
      firstStartBall := false; //To adjust the first-of-the-game startball
      
      // Predict -> Intercept -> Hit
      //If it's not my serve then I really should not be here
      if myServe == false
        mode := "Wait";
        Iterate := 0;
      end;
      
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        //                      G?    Air   Vector Abs   Ball speed
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            Iterate := 0;
            myServe := false;
          end;
        end;
      end;
      
      
      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      
      //New plan: Instead of hitting at the peak of the trajectory after bounce...
      //If p2_predicted is outside table, instead intercept the ball by the table edge
      //  Do this by computing an intermediate prediction between p1 and p2 and
      //Else play as normal (i.e. catch it at the peak point somewhere over the table)
      
      //For now
      //Check if the ball will be too difficult to catch at the peak, if so: skip
      if p2_predicted(0)*(-1)^n > 2 || abs(p2_predicted(1)) > 1 || (p2_predicted(2)) > 2
        mode    := "Wait";
        Iterate := 0;
        myServe := false;
      end;
      
      //Implement solution later
      
      //If p1_predicted is close to our table edge but on the table then move to the table edge and hit the ball just after the bounce
      
      
      
      
      doneOnce := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]]
             ,["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]
             ];
      
    if doneOnce == false //Before having computed where to meet the ball
      //v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v); //Default
      v'  := ([1.5*(-1)^n, 0.5*p_ball(1), 0.3] - p_bat) * 7 + 3 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true //Once we have a plan
      ta := sqrt(2* (d_ballBat/2)/maxA);
      
      a_desired = [0.9471*(-1)^(n+1), -(p_ball(1)*0.55), 0.4];
      angle_bat' = (a_desired - angle_bat)/ta; //PW3
      angle_bat = a_desired;
      
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)//0.25
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)//0.25
        //v' = [-30*(p_ball(0)),0,20]; //Default
        v' = [ -23 * p_ball(0)/abs(p_ball(0)) * norm([p_ball(0), p_ball(1), 0]), -p_ball(1)*0, (1/p_ball(2)^2)*3];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
      Iterate := 0;
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (1/r) * (  x*x''+y*y''+z*z'' + x'^2 + y'^2 + z'^2  -r'^2  );
  //theta '' = (((x^2)+(y^2))*(y*x''-x*y'')* -2*(y*x'-x*y')*(x*x'+y*y'))/(x^2+y^2)^2 ;
  theta '' = -( (x^2 + y^2)*( (x'*y'+x*y'')-(y'*x'+x''*y) ) - 2*(y'*x-y*x')*(x*x'+y*y') ) / ( (x^2+y^2)^2 );
  alpha '' = ( -r*(z^3)*r'' + (r^2)*z*( -2*r'^2 + z*z'' - z'^2 ) + (z^3)*r'^2 + (r^3) * ( z*r'' + 2*r'*z' ) + (r^4)*(-z'') )
           / ( (r^3) * ( r^2 - z^2 ) * sqrt( 1- (z^2)/(r^2) ) );
end


/**
 * A ping pong player, with number n.
 * Position and velocity of ball(p_ball,v_ball) are always provided by parent class.
 * maxA is the maximum accerlaration the actuator can handle.
 * */

/**
 * A ping pong player, with number n.
 * Position and velocity of ball(p_ball,v_ball) are always provided by parent class.
 * maxA is the maximum acceleration the actuator can handle.
 * */

class LPHP(n,maxA)
  private
    name      := "LPHP";
    varX      := 0;
    varZ      := 0;
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.2*(-1)^n;
    zp        := 3;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 20 + 10 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.3,0.4];

         if(t < ta)
          v' = maxA* u;
          angle_bat' = (a_desired - angle_bat)/ta;
         // angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
          angle_bat = a_desired;
        else if (norm(p_ball - p_bat)>0.3)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.3)
          v' = [(-1)^(n+1)*5-v(0),0,8-v(2)];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.25*atan(p1_predicted(1)/p1_predicted(0)) + (-1)^(n+1)*atan(v1_predicted(1)/v1_predicted(0)),0.4];
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0.1   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat' = (a_desired - angle_bat)/ta;
      //angle_bat = a_desired;
      if(t < ta)
        
        v' = maxA* u;
       

      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =10*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        varX = 50*(abs(p_ball(0)))-norm(v_ball)*15;
        varZ = varX;     
        v' = [(-1)^(n+1)*varX-v(0),0,varZ-v(2)];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
 
  r'' = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  theta'' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y));
 
end

class Gatz(n,maxA)
  private
    name      := "Gatz";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat acceleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [2,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Startball" && mode ~= "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5*(-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted ~= 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
//**************************************************************************************************  
  //r'' = (1 - z^2/(x^2 + y^2 + z^2))^(1/2)*(x^2 + y^2 + z^2)^(1/2); // Derive correct equation
  /*alpha = theta = ((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/((x^2)+(y^2)); hits the ball*/
  /*r''=1/r*(x*x''+y*y''+z*z''+(x'^2)+(y'^2)+(z'^2)-(r'^2));//mesa/e3w
  //r''=0;
  //alpha''=(x''*y-x*y''+(2*alpha')*(z*z'-r*r'))/((r^2)-(z^2));//panw/katw
  alpha''=-1.7*(((r*r'-z*z')*(z-z*r'))/(r*((r^2)-(z^2)))+((z''-z*r''-z'*r')/(r^2)))/(sqrt((r^2)-(z^2)));
  //theta '' = z; // Derive correct equation
  //theta''=(((r*r'-z*z')*(z-z*r'))/(r*((r^2)-(z^2)))+((z''-z*r''-z'*r')/(r^2)))/(sqrt((r^2)-(z^2)));//ar/de3
  theta''=((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/((x^2)+(y^2));
  //theta''=0;*/
   r''    = (1/r)*(x*x''+y*y''+z*z''+x'*x'+y'*y'+z'*z')- (r')^2;
   alpha''=-1.2*(y''*x-y*x'')/(x^2+y^2)+ ((y'*x-y*x')*(2*x*x'+2*y*y'))/((x^2+y^2)^2);
   theta '' =(x''*y-x*y''+(2*alpha')*(z*z'-r*r'))/(r^2-z^2);// 
//**************************************************************************************************
end

// Weiren She , Amir Askari

/*
Group: Falafel
Group Members: Jafar Qutteineh , Karthi Keyan

Report:
The player for  P6 is based on the player of P4 (not P5) as the effect of quantization and discretization is not considered in this mode.
The following changes were made:  
-Added equations for r'',theta'' , alpha''. The equations were derived by hand and plugged back into acumen.
